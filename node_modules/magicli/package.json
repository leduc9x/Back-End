{
  "_args": [
    [
      {
        "raw": "magicli@0.0.8",
        "scope": null,
        "escapedName": "magicli",
        "name": "magicli",
        "rawSpec": "0.0.8",
        "spec": "0.0.8",
        "type": "version"
      },
      "E:\\GitHub\\Back-End\\node_modules\\convert-excel-to-json"
    ]
  ],
  "_from": "magicli@0.0.8",
  "_id": "magicli@0.0.8",
  "_inCache": true,
  "_location": "/magicli",
  "_nodeVersion": "8.9.0",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/magicli-0.0.8.tgz_1510188181928_0.7488596537150443"
  },
  "_npmUser": {
    "name": "diegozoracky",
    "email": "diego.zoracky@gmail.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "magicli@0.0.8",
    "scope": null,
    "escapedName": "magicli",
    "name": "magicli",
    "rawSpec": "0.0.8",
    "spec": "0.0.8",
    "type": "version"
  },
  "_requiredBy": [
    "/convert-excel-to-json",
    "/inspect-property/inspect-function"
  ],
  "_resolved": "https://registry.npmjs.org/magicli/-/magicli-0.0.8.tgz",
  "_shasum": "920849cf70736076a6c4aa35d5a6866c807fc07b",
  "_shrinkwrap": null,
  "_spec": "magicli@0.0.8",
  "_where": "E:\\GitHub\\Back-End\\node_modules\\convert-excel-to-json",
  "author": {
    "name": "Diego ZoracKy",
    "email": "diego.zoracky@gmail.com",
    "url": "https://github.com/DiegoZoracKy/"
  },
  "bugs": {
    "url": "https://github.com/DiegoZoracKy/magicli/issues"
  },
  "dependencies": {
    "cliss": "0.0.2",
    "find-up": "^2.1.0",
    "for-each-property": "0.0.4",
    "inspect-property": "0.0.6"
  },
  "description": "Automagically generates command-line interfaces (CLI) for any module. Expected options and help sections are created automatically based on parameters names, with support to async.",
  "devDependencies": {
    "mocha": "^4.0.1"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-x/eBenweAHF+DsYy172sK4doRxZl0yrJnfxhLJiN7H6hPM3Ya0PfI6uBZshZ3ScFFSQD7HXgBqMdbnXKEZsO1g==",
    "shasum": "920849cf70736076a6c4aa35d5a6866c807fc07b",
    "tarball": "https://registry.npmjs.org/magicli/-/magicli-0.0.8.tgz"
  },
  "gitHead": "6a32da93599fb9000dc61ce4066130a706df499e",
  "homepage": "https://github.com/DiegoZoracKy/magicli#readme",
  "keywords": [
    "bin",
    "cli",
    "async",
    "simple",
    "command-line",
    "interface"
  ],
  "license": "MIT",
  "main": "lib/magicli.js",
  "maintainers": [
    {
      "name": "diegozoracky",
      "email": "diego.zoracky@gmail.com"
    }
  ],
  "name": "magicli",
  "optionalDependencies": {},
  "readme": "# MagiCLI\n\n[![Build Status](https://api.travis-ci.org/DiegoZoracKy/magicli.svg)](https://travis-ci.org/DiegoZoracKy/magicli) [![npm](https://img.shields.io/npm/v/magicli.svg)]() [![npm](https://img.shields.io/npm/l/magicli.svg)]()\n\nAutomagically generates command-line interfaces (CLI), for any module.\nJust `require('magicli')();` and your module is ready to be executed via CLI.\n\nThe main goal is to have any module prepared to be executed via CLI (installed globally with `-g`, or by using **npx**):\n\n## Goals\n\n * Minimal setup (*one line*)\n * Automatic options names based on functions parameters\n * Out of the box support to async functions (`Promises`, or any *thenable* lib)\n * A specific help section for each nested property (*\"subcommands\"*)\n * *Name*, *Description* and *Version* extracted from package.json\n * Simple API to hook into the execution flow (*stdin*, *before*, *after*)\n * Cover all possible cases of module.exports (*Function*, *Object* with nested properties, Destructuring parameters)\n\n## Usage (the most simple and minimal way)\n\n * `npm install magicli`\n * Add the property **bin** to your package.json containing the value **./bin/magicli.js**\n * Create the file **./bin/magicli.js** with the following content:\n\n```javascript\n#!/usr/bin/env node\n\nrequire('magicli')();\n```\n\n**Done!** Install your module with `-g`, or use it via **[npx](http://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner)**, and run it with `--help` to see the result. The `--version` option will show the same value found at *package.json*. In the same way you can just run `node ./bin/magicli.js --help` to test it quickly, without installing it.\n\nLet's suppose that **your-module** exports the function:\n\n```javascript\nmodule.exports = function(param1, param2) {\n    return param1 + param2;\n}\n```\n\nWhen calling it via CLI, with `--help`, you will get:\n\n```bash\nDescription:\n\n  Same description found at package.json\n\nUsage:\n\n  $ your-module [options]\n\nOptions:\n\n  --param1\n  --param2\n```\n\nThe program will be expecting options with the same name as the parameters declared at the exported function, and it doesn't need to follow the same order. Example:\n\n`$ your-module --param2=\"K\" --param1=\"Z\"` would result in: `ZK`.\n\n### How it works\n\nMagiCLI is capable of handling many styles of `exports`, like:\n\n * Functions\n * Object Literal\n * Nested properties\n * Class with static methods\n\nAnd also any kind of parameters declaration (*Destructuring Parameters*, *Rest Parameters*).\n\nIf **your-module** were like this:\n```javascript\n// An Arrow function with Destructuring assignment and Default values\nconst mainMethod = ([p1, [p2]] = ['p1Default', ['p2Default']], { p3 = 'p3Default' } = {}) => `${p1}-${p2}-${p3}`;\n\n// Object Literal containing a nested method\nmodule.exports = {\n\tmainMethod,\n\tnested: {\n\t\tmethod: param => `nested method param value is: \"${param}`\n\t}\n};\n```\n\n`$ your-module --help` would result in:\n\n```bash\nDescription:\n\n  Same description found at package.json\n\nUsage:\n\n  $ your-module <command>\n\nCommands:\n\n  mainMethod\n  nested-method\n```\n\n`$ your-module mainMethod --help` would be:\n\n```bash\nUsage:\n\n  $ your-module mainMethod [options]\n\nOptions:\n\n  --p1\n  --p2\n  --p3\n```\n\n`$ your-module nested-method --help` returns:\n\n```bash\nUsage:\n\n  $ your-module nested-method [options]\n\nOptions:\n\n  --param\n```\n\nCalling *mainMethod* without any parameter:\n`$ your-module mainMethod`\n\nresults in:\n` p1Default-p2Default-p3Default`\n\nWhile defining the parameter for *nested-method*:\n`$ your-module mainMethod nested-method --param=paramValue`\n\nwould return:\n` nested method param value is: \"paramValue\"`\n\nNote: Nested methods/properties will be turned into commands separated by `-`, and it can be configurable via options (`subcommandDelimiter`).\n\n## Usage Options\n`magicli({ commands = {}, validateRequiredParameters = false, help = {}, version = {}, pipe = {}, enumerability = 'enumerable', subcommandDelimiter = '-'})`\n\nOptions are provided to add more information about commands and its options, and also to support a better control of a command execution flow, without the need to change the source code of the module itself (for example, to `JSON.stringify` an `Object Literal` that is returned).\n\n\n\n### enumerability\n\nBy default, only the enumerable nested properties will be considered. The possible values are: `'enumerable'` (default), `'nonenumerable'` or `'all'`.\n\n### validateRequiredParameters\nMagiCLI can validate the required parameters for a command and show the help in case some of them are missing. The default value is `false`.\n\n### help\n\n**help.option**\nTo define a different option name to show the help section. For example, if `'modulehelp'` is chosen, `--modulehelp` must be used instead of `--help` to show the help section.\n\n**help.stripAnsi**\n\tSet to `true` to strip all ansi escape codes (colors, underline, etc.) and output just a raw text.\n\n\n\n### version\n**version.option**\nTo define a different option name to show the version. For example, if `'moduleversion'` is chosen, `--moduleversion` must be used instead of `--version` to show the version number.\n\n### pipe (stdin, before and after)\n\nThe pipeline of a command execution is:\n\n**stdin** (command.pipe.stdin || magicliOptions.pipe.stdin) =>\n\n**magicliOptions.pipe.before** =>\n\n**command.pipe.before** =>\n\n**command.action** (the method in case) =>\n\n**command.pipe.after** =>\n\n**magicliOptions.pipe.after** =>\n\n**stdout**\n\nWhere each of these steps can be handled if needed.\n\nAs it can be defined on *commands* option, for each command, **pipe** can also be defined in *options* to implement a common handler for all commands. The expected properties are:\n\n**pipe.stdin**\n`(stdinValue, args, positionalArgs, argsAfterEndOfOptions)`\n\nUseful to get a value from *stdin* and set it to one of the expected *args*.\n\n**pipe.before**\n`(args, positionalArgs, argsAfterEndOfOptions)`\n\nTo transform the data being input, before it is passed in to the main command action.\n\n**pipe.after**\n`(result, parsedArgs, positionalArgs, argsAfterEndOfOptions)`\n\nNote: **stdin** and **before** must always return *args*, and **after** must always return *result*, as these values will be passed in for the next function in the pipeline.\n\n### commands\nThe options are effortlessly extracted from the parameters names, however it is possible to give more information about a command and its options, and also give instructions to the options parser.\n\n**commands** expects an `Object Literal` where each key is the command name. It would be the module's name for the main function that is exported, and the command's name as it is shown at the *Commands:* section of `--help`. For example:\n```javascript\ncommands: {\n    'mainmodulename': {},\n    'some-nested-method': {}\n}\n```\n\nFor each command the following properties can be configurable:\n\n#### options\nIs an *Array* of *Objects*, where each contains:\n\n**name** (*required*)\nThe name of the parameter that will be described\n\n**required**\nTo tell if the parameter is required.\n\n**description**\nTo give hints or explain what the option is about.\n\n**type**\nTo define how the parser should treat the option (Array, Object, String, Number, etc.).  Check [yargs-parser](https://github.com/yargs/yargs-parser) for instructions about *type*, as it is the engine being used to parse the options.\n\n**alias**\nTo define an alias for the option.\n\n#### pipe (stdin, before and after)\n\nThe pipeline of a command execution is:\n\n**stdin** (command.pipe.stdin || magicliOptions.pipe.stdin) =>\n\n**magicliOptions.pipe.before** =>\n\n**command.pipe.before** =>\n\n**command.action** (the method in case) =>\n\n**command.pipe.after** =>\n\n**magicliOptions.pipe.after** =>\n\n**stdout**\n\nWhere each of these steps can be handled if needed.\n\nAs it can be defined on *options* to implement a common handler for all commands, **pipe** can also be defined for each command.\n\n**pipe.stdin**\n`(stdinValue, args, positionalArgs, argsAfterEndOfOptions)`\n\nUseful to get a value from *stdin* and set it to one of the expected *args*.\n\n**pipe.before**\n`(args, positionalArgs, argsAfterEndOfOptions)`\n\nTo transform the data being input, before it is passed in to the main command action.\n\n**pipe.after**\n`(result, parsedArgs, positionalArgs, argsAfterEndOfOptions)`\n\nNote: **stdin** and **before** must always return *args*, and **after** must always return *result*, as these values will be passed in for the next function in the pipeline.\n\nIf needed, a more thorough guide about this section can be found at [cliss](https://github.com/DiegoZoracKy/cliss) (as this is the module under the hood to handle that)\n\nA full featured use of the module would look like:\n\n```javascript\nmagicli({\n\tcommands,\n\tenumerability,\n\tsubcommandDelimiter,\n\tvalidateRequiredParameters,\n\thelp: {\n\t\toption,\n\t\tstripAnsi\n\t},\n\tversion: {\n\t\toption\n\t},\n\tpipe: {\n\t\tstdin: (stdinValue, args, positionalArgs, argsAfterEndOfOptions) => {},\n\t\tbefore: (args, positionalArgs, argsAfterEndOfOptions) => {},\n\t\tafter: (result, parsedArgs, positionalArgs, argsAfterEndOfOptions) => {}\n\t}\n});\n```\n\n## Example\n\nTo better explain with an example, let's get the following module and configure it with MagiCLI to:\n\n * Define **p1** as `String` (*mainMethod*)\n * Write a description for **p2** (*mainMethod*)\n * Define **p3** as required (*mainMethod*)\n * Get **p2** from stdin (*mainMethod*)\n * Use **before** (command) to upper case **param** (*nested-method*)\n * Use **after** (command) to JSON.stringify the result of (*nested-method*)\n * Use **after** (options) to decorate all outputs (*nested-method*)\n\n**module** (\"main\" property of package.json)\n```javascript\n'use strict';\n\nmodule.exports = {\n\tmainMethod: (p1, p2, { p3 = 'p3Default' } = {}) => `${p1}-${p2}-${p3}`,\n\tnested: {\n\t\tmethod: param => {\n\n\t\t\t// Example of a Promise being handled\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tresolve({ param });\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t}\n\t}\n};\n```\n\n**magicli.js** (\"bin\" property of package.json)\n```javascript\n#!/usr/bin/env node\n\n\nrequire('../magicli')({\n\tcommands: {\n\t\t'mainMethod': {\n\t\t\toptions: [{\n\t\t\t\tname: 'p1',\n\t\t\t\tdescription: 'Number will be converted to String',\n\t\t\t\ttype: 'String'\n\t\t\t}, {\n\t\t\t\tname: 'p2',\n\t\t\t\tdescription: 'This parameter can be defined via stdin'\n\t\t\t}, {\n\t\t\t\tname: 'p3',\n\t\t\t\trequired: true\n\t\t\t}],\n\t\t\tpipe: {\n\t\t\t\tstdin: (stdinValue, args, positionalArgs, argsAfterEndOfOptions) => {\n\t\t\t\t\targs.p2 = stdinValue;\n\t\t\t\t\treturn args;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'nested-method': {\n\t\t\toptions: [{\n\t\t\t\tname: 'param',\n\t\t\t\tdescription: 'Wait for it...'\n\t\t\t}],\n\t\t\tpipe: {\n\t\t\t\tbefore: (args, positionalArgs, argsAfterEndOfOptions) => {\n\t\t\t\t\tif (args.param) {\n\t\t\t\t\t\targs.param = args.param.toUpperCase();\n\t\t\t\t\t}\n\t\t\t\t\treturn args;\n\t\t\t\t},\n\n\t\t\t\tafter: JSON.stringify\n\t\t\t}\n\t\t}\n\t},\n\tpipe: {\n\t\tafter: (result, positionalArgs, argsAfterEndOfOptions) => `======\\n${result}\\n======`\n\t}\n});\n```\n\n## Tests\n\nThere is another repository called [MagiCLI Test Machine](https://github.com/DiegoZoracKy/magicli-test-machine), where many real published modules are being successfully tested. As the idea is to keep increasing the number of real modules tested, it made more sense to maintain a separated repository for that, instead of being constantly increasing the size of MagiCLI itself over time. I ask you to contribute with the growing numbers of those tests by adding your own module there via a pull request.\n\nIf you find some case that isn't being handled properly, please open an *issue* or feel free to create a PR ;)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/DiegoZoracKy/magicli.git"
  },
  "scripts": {
    "test": "mocha ./tests/main.test.js",
    "test:all": "mocha ./tests -b"
  },
  "version": "0.0.8"
}
